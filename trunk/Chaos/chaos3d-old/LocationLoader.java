package cz.kotuc.chaos;

import java.applet.Applet;
import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.event.*;
import java.awt.GraphicsConfiguration;
import com.sun.j3d.utils.applet.MainFrame; 
import com.sun.j3d.utils.universe.*;
import com.sun.j3d.utils.geometry.*;
import javax.media.j3d.*;
import javax.vecmath.*;
import com.sun.j3d.utils.image.*;

import com.sun.j3d.loaders.*;
import com.sun.j3d.loaders.objectfile.*;

import java.util.*;


import java.io.*;
import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;

public class LocationLoader extends DefaultHandler {

	static public Location location = null;
	
	public LocationLoader() {
	}
	
	public LocationLoader(Location location) {
		this.location=location;
	}

	// *************************
	// ****loading from XML file
	// **************************

static public void load(String filename)
    {           
        // Use an instance of ourselves as the SAX event handler
        DefaultHandler handler = new LocationLoader();
        // Use the validating parser
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setValidating(true);
        //factory.setNamespaceAware(true);
        try {
            // Set up output stream
            out = new OutputStreamWriter(System.out, "UTF8");

            // Parse the input
            SAXParser saxParser = factory.newSAXParser();
            saxParser.parse( new File(filename), handler);

	    } catch (SAXParseException spe) {
           // Error generated by the parser
           System.out.println("\n** Parsing error"
              + ", line " + spe.getLineNumber()
              + ", uri " + spe.getSystemId());
           System.out.println("   " + spe.getMessage() );

           // Use the contained exception, if any
           Exception  x = spe;
           if (spe.getException() != null)
               x = spe.getException();
           x.printStackTrace();

        } catch (SAXException sxe) {
           // Error generated by this application
           // (or a parser-initialization error)
           Exception  x = sxe;
           if (sxe.getException() != null)
               x = sxe.getException();
           x.printStackTrace();

        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            pce.printStackTrace();

        } catch (IOException ioe) {
           // I/O error
           ioe.printStackTrace();
        }
    }

	static private Writer  out;
    static public String indentString = "    "; // Amount to indent
    static public int indentLevel = 0;
	
	static int curx=0, cury=0, curz=0;

	public void startDocument() throws SAXException {
        //emit("loading: ");
    }

    public void endDocument() throws SAXException {
        emit("location loaded");
    }
	
	public void startElement(String namespaceURI,
                             String lName, // local name
                             String qName, // qualified name
                             Attributes attrs)
    throws SAXException
    {
        indentLevel++;
        String eName = lName; // element name
        if ("".equals(eName)) eName = qName; // namespaceAware = false
                
        if ("location".equals(eName)) {        	
        	emit("location file, loading started");
        	location.widthx = 20;
        	location.widthy = 20;
        	if (attrs.getValue("width")!=null) location.widthx = Integer.parseInt(attrs.getValue("width"));
			if (attrs.getValue("height")!=null) location.widthy = Integer.parseInt(attrs.getValue("height"));
			double random = 0.0;
			if (attrs.getValue("random")!=null) random = Double.parseDouble(attrs.getValue("random"));
			location.initLandVerts(random);			
        };
      	
      	if ("tree".equals(eName)) {        	
        	emit("new Tree");
        	double x = 0;
        	double y = 0;
        	if (attrs.getValue("x")!=null) x = Double.parseDouble(attrs.getValue("x"));
			if (attrs.getValue("y")!=null) y = Double.parseDouble(attrs.getValue("y"));
			location.createTree(x, y);			
        };
		
		if ("house".equals(eName)) {        	
        	emit("new House");
        	double x = 0;
        	double y = 0;
        	double rotz = 0;
        	if (attrs.getValue("x")!=null) x = Double.parseDouble(attrs.getValue("x"));
			if (attrs.getValue("y")!=null) y = Double.parseDouble(attrs.getValue("y"));
			if (attrs.getValue("rotz")!=null) rotz = Double.parseDouble(attrs.getValue("rotz"));
			location.createHouse(x, y, rotz);			
        };
		      
/*      	if ("player".equals(eName)) {        	
//	player is loaded only on first time        	
       	if (location.player==null) {
        		emit("setting player");
//        		double x = 0;
//        		double y = 0;
//       		double z = 0;
//        		double rotz = 0;
        		
        		new Player();
				
				Point3d pos = new Point3d();
				        		
        		if (attrs.getValue("x")!=null) pos.x = Double.parseDouble(attrs.getValue("x"));
				if (attrs.getValue("y")!=null) pos.y = Double.parseDouble(attrs.getValue("y"));
				if (attrs.getValue("z")!=null) pos.z = Double.parseDouble(attrs.getValue("z"));
				
				location.player.setPos(pos);
				
				if (attrs.getValue("rotz")!=null) location.player.angle = Double.parseDouble(attrs.getValue("rotz"));
			};
        };
*/
      	if ("darkball".equals(eName)) {        	
        	emit("new DarkBall");
        		
        	DarkBall darkBall = new DarkBall();
				        		
        	Point3d pos = new Point3d();
				        		
        	if (attrs.getValue("x")!=null) pos.x = Double.parseDouble(attrs.getValue("x"));
			if (attrs.getValue("y")!=null) pos.y = Double.parseDouble(attrs.getValue("y"));
			if (attrs.getValue("z")!=null) pos.z = Double.parseDouble(attrs.getValue("z"));
				
			darkBall.setPos(pos);
				
//			if (attrs.getValue("rotz")!=null) darkBall.angle = Double.parseDouble(attrs.getValue("rotz"));
				
        };
		
/**
 *		loading phaseMap
 */		

		if ("phasemap".equals(eName)) {        	
        	emit("new phaseMap");
        	
        	location.phaseMap = new int[Integer.parseInt(attrs.getValue("widthx"))][][];
        	curx=0;
        		
        };		
		
		if ("phasex".equals(eName)) {        	
        	emit("new phasex");
        	
        	location.phaseMap[curx] = new int[Integer.parseInt(attrs.getValue("widthy"))][];
        	cury=0;
        };
				
		if ("phasey".equals(eName)) {        	
        	emit("new phasey");
        	
        	if (attrs.getValue("height")!=null)
	        	location.phaseMap[curx][cury] = new int[Integer.parseInt(attrs.getValue("height"))];
        	else location.phaseMap[curx][cury] = new int[1];
    
        	curz=0;
        };
		
		if ("phase".equals(eName)) {        	
        	emit("new phase");
        	
        	int type=0;
        	String typeString = attrs.getValue("type");
        	
        	if ("air".equals(typeString)) type=Location.AIR;
        	if ("water".equals(typeString)) type=Location.WATER;
        	if ("solid".equals(typeString)) type=Location.SOLID;
			        	       	
        	location.phaseMap[curx][cury][curz]=type;
        };
      
        if (attrs != null) {
            for (int i = 0; i < attrs.getLength(); i++) {
                String aName = attrs.getLocalName(i); // Attr name 
                if ("".equals(aName)) aName = attrs.getQName(i);
                nl();
                emit(eName);
                emit(".");
                emit(aName);
                emit("=");
                emit(attrs.getValue(i));
                emit("");
            }
        }
        if (attrs.getLength() > 0) nl();
        emit(">");
    }

    public void endElement(String namespaceURI,
                           String sName, // simple name
                           String qName  // qualified name
                          )
    throws SAXException
    {
        String eName = sName; // element name
        if ("".equals(eName)) eName = qName;
        
        if ("location".equals(eName)) {
        	location.createLand();
        };
/*        
        if ("phasemap".equals(eName)) {
        	emit("creating phasemap");
        	location.createPhaseMap();
        }
       
        if ("phasex".equals(eName)) curx++;
                
        if ("phasey".equals(eName)) cury++;
        
        if ("phase".equals(eName)) curz++;
 */       
            
        nl();
        emit("</"+eName+">");
        indentLevel--;
    }

    public void characters(char buf[], int offset, int len)
    throws SAXException
    {
        nl(); emit("CHARS:   ");
        String s = new String(buf, offset, len);
        if (!s.trim().equals("")) emit(s);
    }

    public void ignorableWhitespace(char buf[], int offset, int len)
    throws SAXException
    {
        // Ignore it
    }

    public void processingInstruction(String target, String data)
    throws SAXException
    {
        nl();
        emit("PROCESS: ");
        emit("<?"+target+" "+data+"?>");
    }

    //===========================================================
    // SAX ErrorHandler methods
    //===========================================================

    // treat validation errors as fatal
    public void error(SAXParseException e)
    throws SAXParseException
    {
        throw e;
    }

    // dump warnings too
    public void warning(SAXParseException err)
    throws SAXParseException
    {
        System.out.println("** Warning"
            + ", line " + err.getLineNumber()
            + ", uri " + err.getSystemId());
        System.out.println("   " + err.getMessage());
    }

    //===========================================================
    // Utility Methods ...
    //===========================================================

    // Wrap I/O exceptions in SAX exceptions, to
    // suit handler signature requirements
    private void emit(String s)
    throws SAXException
    {
        try {
            out.write(s);
            out.flush();
        } catch (IOException e) {
            throw new SAXException("I/O error", e);
        }
    }

    // Start a new line
    // and indent the next line appropriately
    private void nl()
    throws SAXException
    {
        String lineEnd =  System.getProperty("line.separator");
        try {
            out.write(lineEnd);
            for (int i=0; i < indentLevel; i++) out.write(indentString);
        } catch (IOException e) {
            throw new SAXException("I/O error", e);
        }
    }
}
	