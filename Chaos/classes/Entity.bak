/**
 *	Entity v 0.01;
 *
 *	Tomas Kotula as Kotuc (=disc)
 */


import java.util.*;
import java.io.*;

import com.sun.j3d.loaders.*;
import com.sun.j3d.loaders.objectfile.*;

import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;

import com.sun.j3d.utils.geometry.*;
import com.sun.j3d.utils.universe.*;
import javax.media.j3d.*;
import javax.vecmath.*;

//import com.sun.j3d.utils.behaviors.keyboard.*;

abstract class Entity {
	
	public Point3d pos = null;
	
	double rotZ = 0.0;
	
	int maxHitpoints=100;
	int hitpoints=maxHitpoints;
	
	BranchGroup objRoot = null; // the branch where entity is added
			
	TransformGroup objTrans = null;	// after it through
	
	private Transform3D tSet = null;		// move obj entity, which is
	private Transform3D tRot = null;		// its avatar,
											// to its current position
	public BranchGroup objEntity = null;			
	
	public Node objHPindicator = null;
	
	Location location = null;
	
	long time = 0;
	
	Vector3d velocity = null;

	public Transform3D getTransform() {
		return tSet;
	}

	public void setPos(Point3d point) {
		this.pos = point;
	}
	
	public void setPos(double x, double y, double z) {
		this.pos.x=x;
		this.pos.y=y;
		this.pos.z=z;
	}
	
	public Point3d getPos() {
		return this.pos;
	}

	public void setRotZ(double zAngle) {
		this.rotZ=zAngle;
	}
	public double setRotZ() {
		return this.rotZ;
	}
	
	
	public Entity (Location location) {
		this.location=location;
		
		pos = new Point3d(5, 5, 2);
		
		this.objRoot = location.objLocation;

		velocity = new Vector3d();
				
		tSet = new Transform3D();
		tSet.set(new Vector3f(this.getPos()));
		tRot = new Transform3D();
		tRot.rotZ(this.rotZ);
		tSet.mul(tRot);
		objTrans = new TransformGroup(tSet);
		objTrans.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
		objTrans.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
		
		objTrans.addChild(createHPindicator());
		
		objEntity=createAvatar();
							
		objEntity.setCapability(Node.ALLOW_BOUNDS_READ);
		objEntity.setCapability(Group.ALLOW_COLLISION_BOUNDS_READ);
		
		objRoot.addChild(objTrans);
		objTrans.addChild(objEntity);
	
		new EntityBehavior(this);
		
		location.addEntity(this);		
	}	
	
//	CollisionDetector collisionDetector;
	
/*	public void createCollisionDetector() {
		collisionDetector = new CollisionDetector();
		objEntity.addChild(collisionDetector);
		collisionDetector.setSchedulingBounds(new BoundingSphere(new Point3d(),1000.0));	
	}
*/	
	public boolean attack(Entity entity, Bounds bounds) {
//		Transform3D tBounds = this.getTransform();
// 		Transform3D tRightHandSet = bounds.getTransform();
//		tRightHandSet.set(new Vector3f(1.5f, -0.4f, 1.5f));
//		rightAttackBounds.getLocalToVworld(tBounds);
//		tBounds.mul(tRightHandSet);
//		bounds.transform(bounds, tBounds);
		return entity.attacked(this, bounds);
	}
	
	public boolean attacked(Entity entity, Bounds bounds) {
		Bounds thisBounds = this.objEntity.getBounds();
		thisBounds.transform(this.getTransform());	
		if (entity!=this&&entity.hitpoints>0&&thisBounds.intersect(bounds)) {
			this.hitpoints-=10; // - entity .strength * .dexterity * .weaponattack
			System.out.println(this + ": \"au\", " + this.hitpoints + " HP left\n");
			System.out.println(bounds + "\nhit " + thisBounds + "\n");
			return true;
		} else {
//			System.out.println(bounds + "\nmiss " + thisBounds + "\n");
			return false;	
		}
	}
	
	Appearance hpAppear;
	
	public Group createHPindicator () {
		hpAppear = new Appearance();
		hpAppear.setCapability(Appearance.ALLOW_COLORING_ATTRIBUTES_WRITE);

		objHPindicator = new Sphere(0.1f, hpAppear);
		objHPindicator.setCapability(Primitive.ENABLE_APPEARANCE_MODIFY);
		
		Transform3D tSet = new Transform3D();
		tSet.set(new Vector3f(0.0f, 0.0f, 2.5f));
		TransformGroup tg = new TransformGroup(tSet);
		tg.addChild(objHPindicator);
		return tg;
	}
	
	/**
	 *	new Entity should be load
	 *	
	 *	create its geometry 
	 *	and appearance
	 *	use some textures to make it good lookin
	 *
	 *	@return new Branchgroup	
	 *
	 */
	abstract BranchGroup createAvatar();
	
	public void die() {
		System.out.println(this + " dies\n");
	}
	
	/**
	 *	you can be sure your new entity will
	 *	proceed this metod every frame
	 *	you should do actions by this not to 
	 *	make asynchronization among your entities
	 *
	 */
	
	abstract void doEveryFrame(java.util.Enumeration enum);
	
	
	

	/**
	 *	what to do if collide
	 */ 

	abstract public void collisionDetected(Enumeration enum);
	
	Point3d getLower() {
//		Point3d lowerPoint=null;
//		((BoundingBox)this.objEntity.getBounds()).getLower(lowerPoint);		
//		return lowerPoint;
		return new Point3d(this.pos.x-0.3, this.pos.y-0.3, this.pos.z);
	}
	
	Point3d getUpper() {
//		Point3d upperPoint=null;
//		((BoundingBox)this.objEntity.getBounds()).getUpper(upperPoint);		
//		return upperPoint;
		return new Point3d(this.pos.x+0.3, this.pos.y+0.3, this.pos.z+0.8);
	}
	
	boolean validate () {
		Point3d lower = getLower();
		Point3d upper = getUpper();
		
		final int LLL=2, ULL=1, LUL=8, UUL=4;
		
		int coll = 0;
				
		if (location.getPhase(new Point3d(lower.x, lower.y, lower.z))!=Location.AIR) {
			coll|=LLL;
		}
		if (location.getPhase(new Point3d(upper.x, lower.y, lower.z))!=Location.AIR) {
			coll|=ULL;
		}
		if (location.getPhase(new Point3d(upper.x, upper.y, lower.z))!=Location.AIR) {
			coll|=UUL;
		}
		if (location.getPhase(new Point3d(lower.x, upper.y, lower.z))!=Location.AIR) {
			coll|=LUL;
		}
		
		if (coll==0) return true;
		
		double movx=0;
		double movy=0;
		
		switch (coll) {
		case LLL|LUL :
		case LLL :
		case LUL :
			movx=1.0-(lower.x%1.0);
			System.out.println("l*l");
		break;
		case ULL|UUL :
		case ULL :
		case UUL :
			movx=-upper.x%1.0;
			System.out.println("u*l");
		break;
		} 
		
		switch (coll) {
		case LLL|LUL :
		case LLL :
		case ULL :
			movy=1.0-(lower.y%1.0);
			System.out.println("*ll");
		break;
		case ULL|UUL :
		case LUL :
		case UUL :
			movy=-upper.y%1.0;
			System.out.println("*ll");
		break;
		}
		
//		if (movx<movy) this.pos.x+=movx;
//		else this.pos.y+=movy;
		
		return false;  	
	}

}
	
		public class CollisionDetector extends Behavior {
   		private WakeupOnCollisionEntry wEntry;

    	public void initialize() {
			wEntry = new WakeupOnCollisionEntry(objEntity, WakeupOnCollisionEntry.USE_GEOMETRY);
//	collision detector disabled
//			wakeupOn(wEntry);
    	}

		public void processStimulus(Enumeration criteria) {
	    	System.out.print("Entity collision entry: ");
	    	SceneGraphPath sgp = wEntry.getTriggeringPath();
	    	if (sgp!=null) System.out.print(sgp.toString());
	    	    	
	    	collisionDetected(criteria);
	    	wakeupOn(wEntry);
    	}
	}
